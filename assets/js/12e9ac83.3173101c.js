"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5673],{46972:e=>{e.exports=JSON.parse('{"functions":[{"name":"SetFocusedWindow","desc":"Sets the focused window to the window provided, which brings it to the front and makes it active.\\n    ","params":[{"name":"window","desc":"the window to focus.","lua_type":"Types.Widget"}],"returns":[],"function_type":"static","source":{"line":91,"path":"lib/API.lua"}},{"name":"Init","desc":"Initializes Iris and begins rendering. May only be called once.\\n\\nSee [Iris.Shutdown] to stop Iris, or [Iris.Disabled] to temporarily disable Iris.\\n\\nOnce initialized, [Iris.Connect] can be used to create a widget.","params":[{"name":"parentInstance","desc":"where Iris will place widgets UIs under, defaulting to [PlayerGui]","lua_type":"BasePlayerGui?"},{"name":"eventConnection","desc":"the event to determine an Iris cycle, defaulting to [Heartbeat]","lua_type":"(RBXScriptSignal | () -> ())?"},{"name":"config","desc":"","lua_type":"{ [string]: any }?"}],"returns":[{"desc":"","lua_type":"Iris"}],"function_type":"static","source":{"line":70,"path":"lib/init.lua"}},{"name":"Shutdown","desc":"Shuts Iris down. This can only be called once, and Iris cannot be started once shut down.","params":[],"returns":[],"function_type":"static","source":{"line":114,"path":"lib/init.lua"}},{"name":"Connect","desc":"Connects a function which will execute every Iris cycle. [Iris.Init] must be called before connecting.\\n\\nA cycle is determined by the `eventConnection` passed to [Iris.Init] (default to [RunService.Heartbeat]).\\n\\nMultiple callbacks can be added to Iris from many different scripts or modules.","params":[{"name":"callback","desc":"the callback containg the Iris code","lua_type":"() -> ()"}],"returns":[{"desc":"","lua_type":"() -> () -- this uses method syntax for no reason.\\r\\n"}],"function_type":"method","source":{"line":149,"path":"lib/init.lua"}},{"name":"Append","desc":"Inserts any Roblox [Instance] into Iris.\\n\\nThe parent of the inserted instance can either be determined by the `_config.Parent`\\nproperty or by the current parent widget from the stack.","params":[{"name":"userInstance","desc":"the Roblox [Instance] to insert into Iris","lua_type":"GuiObject"}],"returns":[],"function_type":"static","source":{"line":169,"path":"lib/init.lua"}},{"name":"End","desc":"Marks the end of any widgets which contain children. For example:\\n```lua\\n-- Widgets placed here **will not** be inside the tree\\nIris.Text({\\"Above and outside the tree\\"})\\n\\n-- A Tree widget can contain children.\\n-- We must therefore remember to call `Iris.End()` \\nIris.Tree({\\"My First Tree\\"})\\n    -- Widgets placed here **will** be inside the tree\\n    Iris.Text({\\"Tree item 1\\"})\\n    Iris.Text({\\"Tree item 2\\"})\\nIris.End()\\n\\n-- Widgets placed here **will not** be inside the tree\\nIris.Text({\\"Below and outside the tree\\"})\\n```\\n:::caution Caution: Error\\nSeeing the error `Callback has too few calls to Iris.End()` or `Callback has too many calls to Iris.End()`?\\nUsing the wrong amount of `Iris.End()` calls in your code will lead to an error.\\n\\nEach widget called which might have children should be paired with a call to `Iris.End()`, **even if the Widget doesnt currently have any children**.\\n:::","params":[],"returns":[],"function_type":"static","source":{"line":206,"path":"lib/init.lua"}},{"name":"ForceRefresh","desc":"Destroys and regenerates all instances used by Iris. Useful if you want to propogate state changes.\\n:::caution Caution: Performance\\nBecause this function Deletes and Initializes many instances, it may cause **performance issues** when used with many widgets.\\nIn **no** case should it be called every frame.\\n:::","params":[],"returns":[],"function_type":"static","source":{"line":229,"path":"lib/init.lua"}},{"name":"UpdateGlobalConfig","desc":"Customizes the configuration which **every** widget will inherit from.\\n\\nIt can be used along with [Iris.TemplateConfig] to easily swap styles, for example:\\n```lua\\nIris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight) -- use light theme\\n```\\n:::caution Caution: Performance\\nThis function internally calls [Iris.ForceRefresh] so that style changes are propogated.\\n\\nAs such, it may cause **performance issues** when used with many widgets.\\nIn **no** case should it be called every frame.\\n:::","params":[{"name":"deltaStyle","desc":"a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`","lua_type":"{ [string]: any }"}],"returns":[],"function_type":"static","source":{"line":250,"path":"lib/init.lua"}},{"name":"PushConfig","desc":"Allows cascading of a style by allowing styles to be locally and hierarchically applied.\\n\\nEach call to Iris.PushConfig must be paired with a call to [Iris.PopConfig], for example:\\n```lua\\nIris.Text({\\"boring text\\"})\\n\\nIris.PushConfig({TextColor = Color3.fromRGB(128, 0, 256)})\\n    Iris.Text({\\"Colored Text!\\"})\\nIris.PopConfig()\\n\\nIris.Text({\\"boring text\\"})\\n```","params":[{"name":"deltaStyle","desc":"a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`","lua_type":"table"}],"returns":[],"function_type":"static","source":{"line":274,"path":"lib/init.lua"}},{"name":"PopConfig","desc":"Ends a [Iris.PushConfig] style.\\n\\nEach call to [Iris.PopConfig] should match a call to [Iris.PushConfig].","params":[],"returns":[],"function_type":"static","source":{"line":299,"path":"lib/init.lua"}},{"name":"PushId","desc":"Sets the id discriminator for the next widgets. Use [Iris.PopId] to remove it.","params":[{"name":"id","desc":"custom id","lua_type":"Types.ID"}],"returns":[],"function_type":"static","source":{"line":328,"path":"lib/init.lua"}},{"name":"PopId","desc":"Removes the id discriminator set by [Iris.PushId].","params":[],"returns":[],"function_type":"static","source":{"line":339,"path":"lib/init.lua"}},{"name":"SetNextWidgetID","desc":"Sets the id for the next widget. Useful for using [Iris.Append] on the same widget.\\n```lua\\nIris.SetNextWidgetId(\\"demo_window\\")\\nIris.Window({ \\"Window\\" })\\n    Iris.Text({ \\"Text one placed here.\\" })\\nIris.End()\\n\\n-- later in the code\\n\\nIris.SetNextWidgetId(\\"demo_window\\")\\nIris.Window()\\n    Iris.Text({ \\"Text two placed here.\\" })\\nIris.End()\\n\\n-- both text widgets will be placed under the same window despite being called separately.\\n```","params":[{"name":"id","desc":"custom id.","lua_type":"Types.ID"}],"returns":[],"function_type":"static","source":{"line":364,"path":"lib/init.lua"}},{"name":"State","desc":"Constructs a new [State] object. Subsequent ID calls will return the same object.\\n:::info\\nIris.State allows you to create \\"references\\" to the same value while inside your UI drawing loop.\\nFor example:\\n```lua\\nIris:Connect(function()\\n    local myNumber = 5;\\n    myNumber = myNumber + 1\\n    Iris.Text({\\"The number is: \\" .. myNumber})\\nend)\\n```\\nThis is problematic. Each time the function is called, a new myNumber is initialized, instead of retrieving the old one.\\nThe above code will always display 6.\\n***\\nIris.State solves this problem:\\n```lua\\nIris:Connect(function()\\n    local myNumber = Iris.State(5)\\n    myNumber:set(myNumber:get() + 1)\\n    Iris.Text({\\"The number is: \\" .. myNumber})\\nend)\\n```\\nIn this example, the code will work properly, and increment every frame.\\n:::","params":[{"name":"initialValue","desc":"the initial value for the state","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Types.State\\r\\n"}],"function_type":"static","source":{"line":403,"path":"lib/init.lua"}},{"name":"WeakState","desc":"Constructs a new state object, subsequent ID calls will return the same object, except all widgets connected to the state are discarded, the state reverts to the passed initialValue","params":[{"name":"initialValue","desc":"The initial value for the state","lua_type":"any"}],"returns":[],"function_type":"static","source":{"line":424,"path":"lib/init.lua"}},{"name":"ComputedState","desc":"    \\nConstructs a new State object, but binds its value to the value of another State.\\n:::info\\nA common use case for this constructor is when a boolean State needs to be inverted:\\n```lua\\nIris.ComputedState(otherState, function(newValue)\\n    return not newValue\\nend)\\n```\\n:::","params":[{"name":"firstState","desc":"State to bind to.","lua_type":"State"},{"name":"onChangeCallback","desc":"callback which should return a value transformed from the firstState value","lua_type":"function"}],"returns":[],"function_type":"static","source":{"line":458,"path":"lib/init.lua"}},{"name":"ShowDemoWindow","desc":"ShowDemoWindow is a function which creates a Demonstration window. this window contains many useful utilities for coders,\\nand serves as a refrence for using each part of the library. Ideally, the DemoWindow should always be available in your UI.\\nIt is the same as any other callback you would connect to Iris using [Iris.Connect]\\n```lua\\nIris:Connect(Iris.ShowDemoWindow)\\n```","params":[],"returns":[],"function_type":"static","source":{"line":488,"path":"lib/init.lua"}}],"properties":[{"name":"Disabled","desc":"While Iris.Disabled is true, execution of Iris and connected functions will be paused.\\nThe widgets are not destroyed, they are just frozen so no changes will happen to them.","lua_type":"boolean","source":{"line":34,"path":"lib/init.lua"}},{"name":"Args","desc":"Provides a list of every possible Argument for each type of widget to it\'s index.\\nFor instance, `Iris.Args.Window.NoResize`.\\nThe Args table is useful for using widget Arguments without remembering their order.\\n```lua\\nIris.Window({\\"My Window\\", [Iris.Args.Window.NoResize] = true})\\n```","lua_type":"table","source":{"line":47,"path":"lib/init.lua"}},{"name":"Events","desc":"-todo: work out what this is used for.","lua_type":"table","ignore":true,"source":{"line":56,"path":"lib/init.lua"}},{"name":"TemplateConfig","desc":"TemplateConfig provides a table of default styles and configurations which you may apply to your UI.","lua_type":"table","source":{"line":310,"path":"lib/init.lua"}}],"types":[],"name":"Iris","desc":"Iris; contains the all user-facing functions and properties.\\nA set of internal functions can be found in `Iris.Internal` (only use if you understand).\\n\\nIn its simplest form, users may start Iris by using\\n```lua\\nIris.Init()\\n\\nIris:Connect(function()\\n    Iris.Window({\\"My First Window!\\"})\\n        Iris.Text({\\"Hello, World\\"})\\n        Iris.Button({\\"Save\\"})\\n        Iris.InputNum({\\"Input\\"})\\n    Iris.End()\\nend)\\n```","source":{"line":23,"path":"lib/init.lua"}}')}}]);