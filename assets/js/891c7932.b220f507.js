"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4195],{62643:e=>{e.exports=JSON.parse('{"functions":[{"name":"get","desc":"Returns the states current value.\\n    ","params":[],"returns":[{"desc":"","lua_type":"any"}],"function_type":"method","source":{"line":125,"path":"src/client/Iris/Internal.lua"}},{"name":"set","desc":"Allows the caller to assign the state object a new value, and returns the new value.\\n    ","params":[],"returns":[],"function_type":"method","source":{"line":135,"path":"src/client/Iris/Internal.lua"}},{"name":"onChange","desc":"Allows the caller to connect a callback which is called when the states value is changed.\\n    ","params":[],"returns":[],"function_type":"method","source":{"line":156,"path":"src/client/Iris/Internal.lua"}}],"properties":[],"types":[],"name":"State","desc":"This class wraps a value in getters and setters, its main purpose is to allow primatives to be passed as objects.\\nConstructors for this class are available in [Iris]\\n\\n```lua\\nlocal state = Iris.State(0) -- we initialise the state with a value of 0\\n\\n-- these are equivalent. Ideally you should use `:get()` and ignore `.value`.\\nprint(state:get())\\nprint(state.value)\\n\\nstate:set(state:get() + 1) -- increments the state by getting the current value and adding 1.\\n\\nstate:onChange(function(newValue)\\n    print(`The value of the state is now: {newValue}`)\\nend)\\n```\\n\\n:::caution\\nNever call \':set()` on a state when inside the the `:onChange()` callback of the same state. This will cause a continous callback.\\n\\nNever chain states together so that each state changes the value of another state in a cyclic nature. This will cause a continous callback.\\n:::\\n    ","source":{"line":114,"path":"src/client/Iris/Internal.lua"}}')}}]);