"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4967],{46972:e=>{e.exports=JSON.parse('{"functions":[{"name":"SetFocusedWindow","desc":"Sets the focused window to the window provided, which brings it to the front and makes it active.\\n    ","params":[{"name":"window","desc":"the window to focus.","lua_type":"Types.Widget"}],"returns":[],"function_type":"static","source":{"line":89,"path":"src/client/Iris/API.lua"}},{"name":"Init","desc":"Initializes Iris and begins rendering. May only be called once.\\nBy default, Iris will create its widgets under the PlayerGui and use the Heartbeat event.","params":[{"name":"parentInstance","desc":"instance which Iris will place UI in. defaults to [PlayerGui] if unspecified","lua_type":"Instance | nil"},{"name":"eventConnection","desc":"","lua_type":"RBXScriptSignal | () -> {} | nil"}],"returns":[{"desc":"","lua_type":"Iris"}],"function_type":"static","source":{"line":54,"path":"src/client/Iris/init.lua"}},{"name":"Connect","desc":"Allows users to connect a function which will execute every Iris cycle, (cycle is determined by the callback or event passed to Iris.Init or default to Heartbeat).\\nMultiple callbacks can be added to Iris from many different scripts or modules.","params":[{"name":"callback","desc":"the callback containg the Iris code.","lua_type":"function"}],"returns":[],"function_type":"method","source":{"line":95,"path":"src/client/Iris/init.lua"}},{"name":"Append","desc":"Allows the caller to insert any Roblox Instance into Iris. The parent can either be determined by the `_config.Parent`\\nproperty or by the current parent widget from the stack.","params":[],"returns":[],"function_type":"static","source":{"line":109,"path":"src/client/Iris/init.lua"}},{"name":"End","desc":"This function marks the end of any widgets which contain children. For example:\\n```lua\\n-- Widgets placed here **will not** be inside the tree\\nIris.Tree({\\"My First Tree\\"})\\n    -- Widgets placed here **will** be inside the tree\\nIris.End()\\n-- Widgets placed here **will not** be inside the tree\\n```\\n:::caution Caution: Error\\nSeeing the error `Callback has too few calls to Iris.End()` or `Callback has too many calls to Iris.End()`?\\nUsing the wrong amount of `Iris.End()` calls in your code will lead to an error. Each widget called which might have children should be paired with a call to `Iris.End()`, **Even if the Widget doesnt currently have any children**.\\n:::","params":[],"returns":[],"function_type":"static","source":{"line":137,"path":"src/client/Iris/init.lua"}},{"name":"ForceRefresh","desc":"Destroys and regenerates all instances used by Iris. Useful if you want to propogate state changes.\\n:::caution Caution: Performance\\nBecause this function Deletes and Initializes many instances, it may cause **performance issues** when used with many widgets.\\nIn **no** case should it be called every frame.\\n:::","params":[],"returns":[],"function_type":"static","source":{"line":161,"path":"src/client/Iris/init.lua"}},{"name":"UpdateGlobalConfig","desc":"Allows callers to customize the config which **every** widget will inherit from.\\nIt can be used along with Iris.TemplateConfig to easily swap styles, ex: ```Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight) -- use light theme```\\n:::caution Caution: Performance\\nthis function internally calls [Iris.ForceRefresh] so that style changes are propogated, it may cause **performance issues** when used with many widgets.\\nIn **no** case should it be called every frame.\\n:::","params":[{"name":"deltaStyle","desc":"a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`","lua_type":"table"}],"returns":[],"function_type":"static","source":{"line":177,"path":"src/client/Iris/init.lua"}},{"name":"PushConfig","desc":"Allows callers to cascade a style, meaning that styles may be locally and hierarchically applied.\\nEach call to Iris.PushConfig must be paired with a call to [Iris.PopConfig].\\nFor example:\\n```lua\\nIris.PushConfig({TextColor = Color3.fromRGB(128, 0, 256)})\\n    Iris.Text({\\"Colored Text!\\"})\\nIris.PopConfig()\\n```","params":[{"name":"deltaStyle","desc":"a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`","lua_type":"table"}],"returns":[],"function_type":"static","source":{"line":198,"path":"src/client/Iris/init.lua"}},{"name":"PopConfig","desc":"Ends a PushConfig style.\\nEach call to [Iris.PushConfig] must be paired with a call to Iris.PopConfig.","params":[],"returns":[],"function_type":"static","source":{"line":223,"path":"src/client/Iris/init.lua"}},{"name":"PushId","desc":"Sets the id discriminator for the next widgets. Use [Iris.PopId] to remove it.","params":[{"name":"id","desc":"custom id.","lua_type":"Types.ID"}],"returns":[],"function_type":"static","source":{"line":253,"path":"src/client/Iris/init.lua"}},{"name":"PopId","desc":"Removes the id discriminator set by [Iris.PushId].","params":[],"returns":[],"function_type":"static","source":{"line":265,"path":"src/client/Iris/init.lua"}},{"name":"PushId","desc":"Sets the id for the next widget. Useful for using [Iris.Append] on the same widget.\\n```lua\\nIris.SetNextWidgetId(\\"demo_window\\")\\nIris.Window({ \\"Window\\" })\\n    Iris.Text({ \\"Text one placed here.\\" })\\nIris.End()\\n\\n-- later in the code\\n\\nIris.SetNextWidgetId(\\"demo_window\\")\\nIris.Window()\\n    Iris.Text({ \\"Text two placed here.\\" })\\nIris.End()\\n\\n-- both text widgets will be placed under the same window despite being called separately.\\n```","params":[{"name":"id","desc":"custom id.","lua_type":"Types.ID"}],"returns":[],"function_type":"static","source":{"line":291,"path":"src/client/Iris/init.lua"}},{"name":"State","desc":"Constructs a new state object, subsequent ID calls will return the same object\\n:::info\\nIris.State allows you to create \\"references\\" to the same value while inside your UI drawing loop.\\nFor example:\\n```lua\\nIris:Connect(function()\\n    local myNumber = 5;\\n    myNumber = myNumber + 1\\n    Iris.Text({\\"The number is: \\" .. myNumber})\\nend)\\n```\\nThis is problematic. Each time the function is called, a new myNumber is initialized, instead of retrieving the old one.\\nThe above code will always display 6.\\n***\\nIris.State solves this problem:\\n```lua\\nIris:Connect(function()\\n    local myNumber = Iris.State(5)\\n    myNumber:set(myNumber:get() + 1)\\n    Iris.Text({\\"The number is: \\" .. myNumber})\\nend)\\n```\\nIn this example, the code will work properly, and increment every frame.\\n:::","params":[{"name":"initialValue","desc":"The initial value for the state","lua_type":"any"}],"returns":[],"function_type":"static","source":{"line":331,"path":"src/client/Iris/init.lua"}},{"name":"State","desc":"Constructs a new state object, subsequent ID calls will return the same object, except all widgets connected to the state are discarded, the state reverts to the passed initialValue","params":[{"name":"initialValue","desc":"The initial value for the state","lua_type":"any"}],"returns":[],"function_type":"static","source":{"line":352,"path":"src/client/Iris/init.lua"}},{"name":"ComputedState","desc":"    \\nConstructs a new State object, but binds its value to the value of another State.\\n:::info\\nA common use case for this constructor is when a boolean State needs to be inverted:\\n```lua\\nIris.ComputedState(otherState, function(newValue)\\n    return not newValue\\nend)\\n```\\n:::","params":[{"name":"firstState","desc":"State to bind to.","lua_type":"State"},{"name":"onChangeCallback","desc":"callback which should return a value transformed from the firstState value","lua_type":"function"}],"returns":[],"function_type":"static","source":{"line":386,"path":"src/client/Iris/init.lua"}},{"name":"ShowDemoWindow","desc":"ShowDemoWindow is a function which creates a Demonstration window. this window contains many useful utilities for coders,\\nand serves as a refrence for using each part of the library. Ideally, the DemoWindow should always be available in your UI.\\nIt is the same as any other callback you would connect to Iris using [Iris.Connect]\\n```lua\\nIris:Connect(Iris.ShowDemoWindow)\\n```","params":[],"returns":[],"function_type":"static","source":{"line":416,"path":"src/client/Iris/init.lua"}}],"properties":[{"name":"Disabled","desc":"While Iris.Disabled is true, execution of Iris and connected functions will be paused.\\nThe widgets are not destroyed, they are just frozen so no changes will happen to them.","lua_type":"boolean","source":{"line":20,"path":"src/client/Iris/init.lua"}},{"name":"Args","desc":"Provides a list of every possible Argument for each type of widget to it\'s index.\\nFor instance, `Iris.Args.Window.NoResize`.\\nThe Args table is useful for using widget Arguments without remembering their order.\\n```lua\\nIris.Window({\\"My Window\\", [Iris.Args.Window.NoResize] = true})\\n```","lua_type":"table","source":{"line":33,"path":"src/client/Iris/init.lua"}},{"name":"Events","desc":"-todo: work out what this is used for.","lua_type":"table","ignore":true,"source":{"line":42,"path":"src/client/Iris/init.lua"}},{"name":"TemplateConfig","desc":"TemplateConfig provides a table of default styles and configurations which you may apply to your UI.","lua_type":"table","source":{"line":234,"path":"src/client/Iris/init.lua"}}],"types":[],"name":"Iris","desc":"Iris; contains the all user-facing functions and properties.\\nA set of internal functions can be found in `Iris.Internal` (only use unless you understand).","source":{"line":10,"path":"src/client/Iris/init.lua"}}')}}]);