"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[673],{46972:e=>{e.exports=JSON.parse('{"functions":[{"name":"ForceRefresh","desc":"Destroys and regenerates all instances used by Iris. useful if you want to propogate state changes.\\n:::caution Caution: Performance\\nBecause this function Deletes and Initializes many instances, it may cause **performance issues** when used with many widgets.\\nIn **no** case should it be called every frame.\\n:::","params":[],"returns":[],"function_type":"static","source":{"line":195,"path":"src/client/Iris/init.lua"}},{"name":"WidgetConstructor","desc":"","params":[{"name":"type","desc":"Name used to denote the widget","lua_type":"string"},{"name":"hasState","desc":"Indicates if the widget will use any state","lua_type":"boolean"},{"name":"hasChildren","desc":"Indicates if the widget will possibly contain any children","lua_type":"boolean"},{"name":"widgetFunctions","desc":"table of methods for the new widget","lua_type":"table"}],"returns":[],"function_type":"static","source":{"line":205,"path":"src/client/Iris/init.lua"}},{"name":"UpdateGlobalConfig","desc":"Allows callers to customize the config which **every** widget will inherit from.\\nIt can be used along with Iris.TemplateConfig to easily swap styles, ex: ```Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight) -- use light theme```\\n:::caution Caution: Performance\\nthis function internally calls [Iris.ForceRefresh] so that style changes are propogated, it may cause **performance issues** when used with many widgets.\\nIn **no** case should it be called every frame.\\n:::","params":[{"name":"deltaStyle","desc":"a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`","lua_type":"table"}],"returns":[],"function_type":"static","source":{"line":258,"path":"src/client/Iris/init.lua"}},{"name":"PushConfig","desc":"Allows callers to cascade a style, meaning that styles may be locally and hierarchically applied.\\nEach call to Iris.PushConfig must be paired with a call to [Iris.PopConfig].\\nFor example:\\n```lua\\nIris.PushConfig({TextColor = Color3.fromRGB(128, 0, 256)})\\n    Iris.Text({\\"Colored Text!\\"})\\nIris.PopConfig()\\n```","params":[{"name":"deltaStyle","desc":"a table containing the changes in style ex: `{ItemWidth = UDim.new(0, 100)}`","lua_type":"table"}],"returns":[],"function_type":"static","source":{"line":276,"path":"src/client/Iris/init.lua"}},{"name":"PopConfig","desc":"Ends a PushConfig style.\\nEach call to [Iris.PushConfig] must be paired with a call to Iris.PopConfig.","params":[],"returns":[],"function_type":"static","source":{"line":297,"path":"src/client/Iris/init.lua"}},{"name":"State","desc":"Constructs a new state object, subsequent ID calls will return the same object\\n:::info\\nIris.State allows you to create \\"references\\" to the same value while inside your UI drawing loop.\\nFor example:\\n```lua\\nIris:Connect(function()\\n    local myNumber = 5;\\n    myNumber = myNumber + 1\\n    Iris.Text({\\"The number is: \\" .. myNumber})\\nend)\\n```\\nThis is problematic. Each time the function is called, a new myNumber is initialized, instead of retrieving the old one.\\nThe above code will always display 6.\\n***\\nIris.State solves this problem:\\n```lua\\nIris:Connect(function()\\n    local myNumber = Iris.State(5)\\n    myNumber:set(myNumber:get() + 1)\\n    Iris.Text({\\"The number is: \\" .. myNumber})\\nend)\\n```\\nIn this example, the code will work properly, and increment every frame.\\n:::","params":[{"name":"initialValue","desc":"The initial value for the state","lua_type":"any"}],"returns":[],"function_type":"static","source":{"line":363,"path":"src/client/Iris/init.lua"}},{"name":"ComputedState","desc":"Constructs a new State object, but binds its value to the value of another State.\\n:::info\\nA common use case for this constructor is when a boolean State needs to be inverted:\\n```lua\\nIris.ComputedState(otherState, function(newValue)\\n    return not newValue\\nend)\\n```\\n:::","params":[{"name":"firstState","desc":"State to bind to.","lua_type":"State"},{"name":"onChangeCallback","desc":"callback which should return a value transformed from the firstState value","lua_type":"function"}],"returns":[],"function_type":"static","source":{"line":391,"path":"src/client/Iris/init.lua"}},{"name":"Init","desc":"Initializes Iris. May only be called once.\\n:::tip\\nWant to stop Iris from rendering and consuming performance, but keep all the Iris code? simply comment out the `Iris.Init()` line in your codebase.\\n:::","params":[{"name":"parentInstance","desc":"instance which Iris will place UI in. defaults to [PlayerGui] if unspecified","lua_type":"Instance | nil"},{"name":"eventConnection","desc":"","lua_type":"RBXScriptSignal | () -> {} | nil"}],"returns":[{"desc":"","lua_type":"Iris"}],"function_type":"static","source":{"line":435,"path":"src/client/Iris/init.lua"}},{"name":"Append","desc":"Allows the caller to insert any Roblox Instance into the current parent Widget.","params":[],"returns":[],"function_type":"static","source":{"line":587,"path":"src/client/Iris/init.lua"}},{"name":"End","desc":"This function marks the end of any widgets which contain children. For example:\\n```lua\\n-- Widgets placed here **will not** be inside the tree\\nIris.Tree({\\"My First Tree\\"})\\n    -- Widgets placed here **will** be inside the tree\\nIris.End()\\n-- Widgets placed here **will not** be inside the tree\\n```\\n:::caution Caution: Error\\nSeeing the error `Callback has too few calls to Iris.End()` or `Callback has too many calls to Iris.End()`?\\nUsing the wrong amount of `Iris.End()` calls in your code will lead to an error. Each widget called which might have children should be paired with a call to `Iris.End()`, **Even if the Widget doesnt currently have any children**.\\n:::","params":[],"returns":[],"function_type":"static","source":{"line":612,"path":"src/client/Iris/init.lua"}},{"name":"ShowDemoWindow","desc":"ShowDemoWindow is a function which creates a Demonstration window. this window contains many useful utilities for coders, and serves as a refrence for using every aspect of the library.\\nIdeally, the DemoWindow should always be available through your UI. ","params":[],"returns":[],"function_type":"static","source":{"line":634,"path":"src/client/Iris/init.lua"}}],"properties":[{"name":"Args","desc":"Provides a list of every possible Argument for each type of widget.\\nFor instance, `Iris.Args.Window.NoResize`.\\nThe Args table is useful for using widget Arguments without remembering their order.\\n```lua\\nIris.Window({\\"My Window\\", [Iris.Args.Window.NoResize] = true})\\n```","lua_type":"table","source":{"line":186,"path":"src/client/Iris/init.lua"}},{"name":"TemplateConfig","desc":"TemplateConfig provides a table of default styles and configurations which you may apply to your UI.","lua_type":"table","source":{"line":623,"path":"src/client/Iris/init.lua"}}],"types":[],"name":"Iris","desc":"Iris is the base class which contains everything you need to use the library.","source":{"line":6,"path":"src/client/Iris/init.lua"}}')}}]);